local record M
    vers_jobs: {string:VersJob}
    deps_jobs: {string:DepsJob}

    record Version
        num: string
        features: Features
        yanked: boolean
        parsed: SemVer
        created: DateTime
        deps: {Dependency}|nil
    end

    record VersJob
        job: Job
        callbacks: {function({Version}, boolean)}
    end

    record DepsJob
        job: Job
        callbacks: {function({Dependency}, boolean)}
    end

    record Features
        {Feature}
    end

    record Feature
        name: string
        members: {string}
    end

    record Dependency
        name: string
        opt: boolean
        kind: Kind
        vers: Vers

        enum Kind
            "normal"
            "build"
            "dev"
        end

        record Vers
            reqs: {Requirement}
            text: string
        end
    end
end

local Version = M.Version
local Features = M.Features
local Feature = M.Feature
local Dependency = M.Dependency
local Job = require("plenary.job")
local semver = require("crates.semver")
local SemVer = semver.SemVer
local Requirement = semver.Requirement
local DateTime = require("crates.time").DateTime

local endpoint = "https://crates.io/api/v1"
local useragent = vim.fn.shellescape("crates.nvim (https://github.com/saecki/crates.nvim)") as string
local json_decode_opts: vim.json.DecodeOpts = { luanil = { object = true, array = true } }

M.vers_jobs = {}
M.deps_jobs = {}


function Features.new(obj: table): Features
    return setmetatable(obj as Features, { __index = Features })
end

function Features:get_feat(name: string): Feature|nil, integer|nil
    for i,f in ipairs(self) do
        if f.name == name then
            return f, i
        end
    end

    return nil, nil
end

function Features:sort()
    table.sort(self, function (a: Feature, b: Feature): boolean
        if a.name == "default" then
            return true
        elseif b.name == "default" then
            return false
        else
            return a.name < b.name
        end
    end)
end


local function parse_versions(json: string): {Version}|nil
    if not json then
        return nil
    end

    local success, data = pcall(vim.json.decode, json, json_decode_opts) as (boolean, {string:{table}})
    if not success then
        data = nil
    end

    local versions: {Version} = {}
    if data and type(data) == "table" and data.versions then
        for _,v in ipairs(data.versions) do
            if v.num then
                local version = {
                    num = v.num,
                    features = Features.new {},
                    yanked = v.yanked,
                    parsed = semver.parse_version(v.num as string),
                    created = DateTime.parse_rfc_3339(v.created_at as string)
                }

                for n,m in pairs(v.features as {string:{string}}) do
                    table.sort(m)
                    table.insert(version.features, {
                        name = n,
                        members = m,
                    })
                end

                -- add optional dependency members as features
                for _,f in ipairs(version.features) do
                    for _,m in ipairs(f.members) do
                        if not version.features:get_feat(m) then
                            table.insert(version.features, {
                                name = m,
                                members = {},
                            })
                        end
                    end
                end

                -- sort features alphabetically
                version.features:sort()

                -- add missing default feature
                if not version.features[1] or not (version.features[1].name == "default") then
                    for i=#version.features, 1, -1 do
                        version.features[i + 1] = version.features[i]
                    end

                    version.features[1] = {
                        name = "default",
                        members = {},
                    }
                end

                table.insert(versions, version)
            end
        end
    end

    return versions
end

function M.fetch_crate_versions(name: string, callback: function({Version}, boolean))
    if M.vers_jobs[name] then
        return
    end

    local callbacks = { callback }
    local url = string.format("%s/crates/%s/versions", endpoint, name)

    local function on_exit(j: Job, code: integer, signal: integer)
        local cancelled = signal ~= 0

        local json: string = nil
        if code == 0 then
            json = table.concat(j:result(), "\n")
        end

        local versions: {Version} = nil
        if not cancelled then
            versions = parse_versions(json)
        end
        for _,c in ipairs(callbacks) do
            c(versions, cancelled)
        end

        M.vers_jobs[name] = nil
    end

    local j = Job:new {
        command = "curl",
        args = { "-sLA", useragent, url },
        on_exit = vim.schedule_wrap(on_exit) as function(Job, integer, integer),
    }

    M.vers_jobs[name] = {
        job = j,
        callbacks = callbacks,
    }

    j:start()
end

local function parse_deps(json: string): {Dependency}
    if not json then
        return nil
    end

    local success, data = pcall(vim.json.decode, json, json_decode_opts) as (boolean, {string:{table}})
    if not success then
        data = nil
    end

    local dependencies: {Dependency} = {}
    if data and type(data) == "table" and data.dependencies then
        for _,d in ipairs(data.dependencies) do
            if d.crate_id then
                table.insert(dependencies, {
                    name = d.crate_id,
                    opt = d.optional or false,
                    kind = d.kind or "normal",
                    vers = {
                        text = d.req,
                        reqs = semver.parse_requirements(d.req as string),
                    },
                })
            end
        end
    end

    return dependencies
end

function M.fetch_crate_deps(name: string, version: string, callback: function({Dependency}, boolean))
    local jobname = name .. ":" .. version
    if M.deps_jobs[jobname] then
        return
    end

    local callbacks = { callback }
    local url = string.format("%s/crates/%s/%s/dependencies", endpoint, name, version)

    local function on_exit(j: Job, code: integer, signal: integer)
        local cancelled = signal ~= 0

        local json: string = nil
        if code == 0 then
            json = table.concat(j:result(), "\n")
        end

        local deps: {Dependency} = nil
        if not cancelled then
            deps = parse_deps(json)
        end
        for _,c in ipairs(callbacks) do
            c(deps, cancelled)
        end

        M.deps_jobs[jobname] = nil
    end

    local j = Job:new {
        command = "curl",
        args = { "-sLA", useragent, url },
        on_exit = vim.schedule_wrap(on_exit) as function(Job, integer, integer),
    }

    M.deps_jobs[jobname] = {
        job = j,
        callbacks = callbacks,
    }

    j:start()
end

function M.is_fetching_vers(name: string): boolean
    return M.vers_jobs[name] ~= nil
end

function M.is_fetching_deps(name: string, version: string): boolean
    return M.deps_jobs[name .. ":" .. version] ~= nil
end

function M.add_vers_callback(name: string, callback: function({Version}, boolean))
    table.insert(
        M.vers_jobs[name].callbacks,
        callback
    )
end

function M.add_deps_callback(name: string, version: string, callback: function({Dependency}, boolean))
    table.insert(
        M.deps_jobs[name .. ":" .. version].callbacks,
        callback
    )
end

function M.cancel_jobs()
    for _,r in pairs(M.vers_jobs) do
        r.job:shutdown(1, 1)
    end
    for _,r in pairs(M.deps_jobs) do
        r.job:shutdown(1, 1)
    end
    M.vers_jobs = {}
    M.deps_jobs = {}
end

return M
